from typing import Sequence

from petsc4py import PETSc

import dolfinx
import ufl

from .matrix_assembler import assemble_matrix, create_matrix
from .vector_assembler import assemble_vector, create_vector


class LinearProblem:
    """High-level class for solving a linear variational problem using
    a PETSc KSP.

    Solves problems of the form
    :math:`a_{ij}(u, v) = f_i(v), i,j=0,\\ldots,N\\
    \\forall v \\in V` where
    :math:`u=(u_0,\\ldots,u_N), v=(v_0,\\ldots,v_N)`
    using PETSc KSP as the linear solver.

    Note:
        This high-level class automatically handles PETSc memory
        management. The user does not need to manually call
        ``.destroy()`` on returned PETSc objects.
    """

    _u: dolfinx.fem.Function | Sequence[dolfinx.fem.Function]

    def __init__(
        self,
        a: ufl.Form,
        L: ufl.Form,
        *,
        petsc_options_prefix: str,
        bcs: Sequence[dolfinx.fem.DirichletBC] | None = None,
        u: Sequence[dolfinx.fem.Function] | None = None,
        P: ufl.Form | None = None,
        petsc_options: dict | None = None,
        form_compiler_options: dict | None = None,
        jit_options: dict | None = None,
        entity_maps: Sequence[dolfinx.mesh.EntityMap] | None = None,
    ) -> None:
        """Initialize solver for a linear variational problem.

        By default, the underlying KSP solver uses PETSc's default
        options, usually GMRES + ILU preconditioning. To use the robust
        combination of LU via MUMPS

        Example::

            problem = LinearProblem(a, L, bcs=[bc0, bc1],
                petsc_options_prefix="basic_linear_problem",
                petsc_options= {
                  "ksp_type": "preonly",
                  "pc_type": "lu",
                  "pc_factor_mat_solver_type": "mumps"
            })


        Every PETSc object created will have a unique options prefix set.
        We recommend discovering these prefixes dynamically via the
        petsc4py API rather than hard-coding each prefix value
        into the programme.

        Example::

            ksp_options_prefix = problem.solver.getOptionsPrefix()
            A_options_prefix = problem.A.getOptionsPrefix()

        Args:
            a: Bilinear UFL form, the left-hand side of the variational problem.
            L: Linear UFL form, the right-hand side of the variational problem.
            bcs: Sequence of Dirichlet boundary conditions to apply to
                 the variational problem and the preconditioner matrix.
            u: Sequence of solution functions. It is created if not provided.
            P: Bilinear UFL form, used as a preconditioner.
            petsc_options_prefix: Mandatory named argument. Options prefix
                used as root prefix on all internally created PETSc
                objects. Typically ends with ``_``. Must be the same on
                all ranks, and is usually unique within the programme.
            petsc_options: Options set on the underlying PETSc KSP only.
                The options must be the same on all ranks. For available
                choices for the ``petsc_options`` kwarg, see the `PETSc KSP
                documentation
                <https://petsc4py.readthedocs.io/en/stable/manual/ksp/>`_.
                Options on other objects (matrices, vectors) should be set
                explicitly by the user.
            form_compiler_options: Options used in FFCx compilation of
                all forms. Run ``ffcx --help`` at the commandline to see
                all available options.
            jit_options: Options used in CFFI JIT compilation of C
                code generated by FFCx. See ``python/dolfinx/jit.py`` for
                all available options. Takes priority over all other
                option values.
            entity_maps: If any trial functions, test functions, or
                coefficients in the form are not defined over the same mesh
                as the integration domain, a corresponding :class:
                `EntityMap<dolfinx.mesh.EntityMap>` must be provided.
        """

        self._a = a
        self._L = L
        self._P = P

        self._form_compiler_options = form_compiler_options
        self._jit_options = jit_options

        self._A = create_matrix(
            self._a,
            form_compiler_options=form_compiler_options,
            jit_options=jit_options,
            entity_maps=entity_maps,
        )  # type: ignore[arg-type]
        if P is None:
            self._P_mat = None
        else:
            self._P_mat = create_matrix(
                P,
                form_compiler_options=form_compiler_options,
                jit_options=jit_options,
                entity_maps=entity_maps,
            )  # type: ignore[arg-type]
        self._b = create_vector(
            self._L,
            form_compiler_options=form_compiler_options,
            jit_options=jit_options,
            entity_maps=entity_maps,
        )  # type: ignore[arg-type]
        self._x = create_vector(
            self._L,
            form_compiler_options=form_compiler_options,
            jit_options=jit_options,
            entity_maps=entity_maps,
        )
        if u is None:
            # Extract function space for unknown from the right hand
            # side of the equation.
            arguments = [arg for arg in self._L.arguments()]
            if len(arguments) > 1:
                blocked_linear_form = ufl.extract_blocks(L)
                self._u = [
                    dolfinx.fem.Function(form.arguments()[0].ufl_function_space())
                    for form in blocked_linear_form
                ]
            else:
                self._u = dolfinx.fem.Function(arguments[0].ufl_function_space())
        else:
            self._u = u

        self.bcs = [] if bcs is None else bcs

        self._solver = PETSc.KSP().create(self.A.comm)  # type: ignore[attr-defined]
        self.solver.setOperators(self.A, self.P_mat)

        if petsc_options_prefix == "":
            raise ValueError("PETSc options prefix cannot be empty.")

        self._petsc_options_prefix = petsc_options_prefix
        self.solver.setOptionsPrefix(petsc_options_prefix)
        self.A.setOptionsPrefix(f"{petsc_options_prefix}A_")
        self.b.setOptionsPrefix(f"{petsc_options_prefix}b_")
        self.x.setOptionsPrefix(f"{petsc_options_prefix}x_")
        if self.P_mat is not None:
            self.P_mat.setOptionsPrefix(f"{petsc_options_prefix}P_mat_")

        # Set options on KSP only
        if petsc_options is not None:
            opts = PETSc.Options()  # type: ignore[attr-defined]
            opts.prefixPush(self.solver.getOptionsPrefix())

            for k, v in petsc_options.items():
                opts[k] = v

            self.solver.setFromOptions()

            # Tidy up global options
            for k in petsc_options.keys():
                del opts[k]

            opts.prefixPop()

        if self._A.getType() == "nest":
            # Transfer nest IS on self.A to PC of main KSP. This allows
            # fieldsplit preconditioning to be applied, if desired.
            nest_IS = self.A.getNestISs()
            fieldsplit_IS = tuple(
                [
                    (f"{u.name + '_' if u.name != 'f' else ''}{i}", IS)
                    for i, (u, IS) in enumerate(zip(self.u, nest_IS[0]))
                ]
            )
            self.solver.getPC().setFieldSplitIS(*fieldsplit_IS)

    def __del__(self):
        self._solver.destroy()
        self._A.destroy()
        self._b.destroy()
        self._x.destroy()
        if self._P_mat is not None:
            self._P_mat.destroy()

    def solve(self) -> dolfinx.fem.Function | Sequence[dolfinx.fem.Function]:
        """Solve the problem.

        This method updates the solution ``u`` function(s) stored in the
        problem instance.

        Note:
            The user is responsible for asserting convergence of the KSP
            solver e.g. ``problem.solver.getConvergedReason() > 0``.
            Alternatively, pass ``"ksp_error_if_not_converged" : True`` in
            ``petsc_options`` to raise a ``PETScError`` on failure.

        Returns:
            The solution function(s).
        """

        # Assemble lhs
        self.A.zeroEntries()
        assemble_matrix(
            self._a,
            bcs=self.bcs,
            form_compiler_options=self._form_compiler_options,
            jit_options=self._jit_options,
            A=self.A,
        )

        # Assemble preconditioner
        if self.P_mat is not None:
            self.P_mat.zeroEntries()
            assert isinstance(self._P, ufl.Form)
            assemble_matrix(
                self._P,
                bcs=self.bcs,
                form_compiler_options=self._form_compiler_options,
                jit_options=self._jit_options,
                A=self.P_mat,
            )

        # Assemble rhs
        dolfinx.la.petsc._zero_vector(self.b)
        assemble_vector(
            self._L,
            bcs=self.bcs,
            form_compiler_options=self._form_compiler_options,
            jit_options=self._jit_options,
            b=self.b,
        )

        # Solve linear system and update ghost values in the solution
        self.solver.solve(self.b, self.x)
        dolfinx.la.petsc._ghost_update(
            self.x,
            PETSc.InsertMode.INSERT,  # type: ignore[attr-defined]
            PETSc.ScatterMode.FORWARD,  # type: ignore[attr-defined]
        )

        dolfinx.fem.petsc.assign(self.x, self._u)
        return self.u

    @property
    def A(self) -> PETSc.Mat:  # type: ignore[name-defined]
        """Left-hand side matrix."""
        return self._A

    @property
    def P_mat(self) -> PETSc.Mat:  # type: ignore[name-defined]
        """Preconditioner matrix."""
        return self._P_mat

    @property
    def b(self) -> PETSc.Vec:  # type: ignore[name-defined]
        """Right-hand side vector."""
        return self._b

    @property
    def x(self) -> PETSc.Vec:  # type: ignore[name-defined]
        """Solution vector.

        Note:
            The vector does not share memory with the solution
            function(s) ``u``.
        """
        return self._x

    @property
    def solver(self) -> PETSc.KSP:  # type: ignore[name-defined]
        """The PETSc KSP solver."""
        return self._solver

    @property
    def u(self) -> dolfinx.fem.Function | Sequence[dolfinx.fem.Function]:
        """Solution function(s).

        Note:
            The function(s) do not share memory with the solution
            vector ``x``.
        """
        return self._u
